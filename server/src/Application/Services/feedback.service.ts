import { Injectable, NotFoundException, Logger } from "@nestjs/common";
import { FeedbackRepository } from "@/Infrastructure/Repositories/feedback.repository";
import { MessageRepository } from "@/Infrastructure/Repositories/message.repository";
import { Feedback } from "@/Domain/Chat/Feedback";
import { CreateFeedbackDto, FeedbackResponseDto } from "@/Application/DTOs";

@Injectable()
export class FeedbackService {
  private readonly logger = new Logger(FeedbackService.name);

  constructor(
    private readonly feedbackRepository: FeedbackRepository,
    private readonly messageRepository: MessageRepository,
  ) {}

  async findAll(
    page: number = 1,
    limit: number = 10,
  ): Promise<{
    feedbacks: FeedbackResponseDto[];
    total: number;
    page: number;
    limit: number;
  }> {
    this.logger.log(
      `Fetching feedbacks with pagination: page=${page}, limit=${limit}`,
    );
    const result = await this.feedbackRepository.findAll(page, limit);
    return {
      feedbacks: result.feedbacks.map((feedback) =>
        this.mapToResponseDto(feedback),
      ),
      total: result.total,
      page,
      limit,
    };
  }

  async findOne(id: string): Promise<FeedbackResponseDto> {
    this.logger.log(`Fetching feedback with ID: ${id}`);
    const feedback = await this.feedbackRepository.findOne(id);
    if (!feedback) {
      this.logger.warn(`Feedback with ID ${id} not found`);
      throw new NotFoundException(`Feedback with ID ${id} not found`);
    }
    return this.mapToResponseDto(feedback);
  }

  async findByChatId(chatId: string): Promise<FeedbackResponseDto[]> {
    this.logger.log(`Fetching feedbacks for chat: ${chatId}`);
    const feedbacks = await this.feedbackRepository.findByChatId(chatId);
    return feedbacks.map((feedback) => this.mapToResponseDto(feedback));
  }

  async create(
    createFeedbackDto: CreateFeedbackDto,
  ): Promise<FeedbackResponseDto> {
    this.logger.log(
      `Creating new feedback for chat: ${createFeedbackDto.chat_id}`,
    );

    // Get the last message if no specific message_ids are provided
    let messageIds = createFeedbackDto.message_ids;
    if (!messageIds || messageIds.length === 0) {
      const lastMessage = await this.messageRepository.findByChatId(
        createFeedbackDto.chat_id,
        undefined,
        1,
        1,
      );
      if (lastMessage.messages.length > 0) {
        messageIds = [lastMessage.messages[0].message_id];
      }
    }

    // Generate AI feedback based on the messages
    const feedbackContent = await this.generateAIFeedback(
      createFeedbackDto.user_prompt,
    );

    // Determine feedback type based on content analysis
    const feedbackType = this.analyzeFeedbackType(feedbackContent);

    const feedback = await this.feedbackRepository.create({
      ...createFeedbackDto,
      feedback_type: feedbackType,
      generation_type: createFeedbackDto.user_prompt
        ? "user_prompt"
        : "ai_suggestion",
      feedback_content: feedbackContent,
    });

    this.logger.log(`Feedback created successfully with ID: ${feedback.id}`);
    return this.mapToResponseDto(feedback);
  }

  private async generateAIFeedback(userPrompt?: string): Promise<string> {
    // TODO: Implement actual AI integration
    // This could be OpenAI, Claude, or other AI services

    if (userPrompt) {
      // Generate feedback based on user prompt
      return `AI Feedback based on user prompt: "${userPrompt}". This is a sample feedback response that would be generated by the AI system.`;
    } else {
      // Generate automatic feedback based on message analysis
      return `AI-generated feedback based on message analysis. This feedback suggests ways to improve customer engagement and conversion.`;
    }
  }

  private analyzeFeedbackType(
    feedbackContent: string,
  ): "positive" | "negative" | "neutral" {
    // Simple analysis based on keywords
    const positiveKeywords = [
      "good",
      "great",
      "excellent",
      "positive",
      "improve",
      "success",
    ];
    const negativeKeywords = [
      "bad",
      "poor",
      "negative",
      "problem",
      "issue",
      "fail",
    ];

    const content = feedbackContent.toLowerCase();

    const positiveCount = positiveKeywords.filter((keyword) =>
      content.includes(keyword),
    ).length;
    const negativeCount = negativeKeywords.filter((keyword) =>
      content.includes(keyword),
    ).length;

    if (positiveCount > negativeCount) {
      return "positive";
    } else if (negativeCount > positiveCount) {
      return "negative";
    } else {
      return "neutral";
    }
  }

  private mapToResponseDto(feedback: Feedback): FeedbackResponseDto {
    return {
      id: feedback.id,
      chat_id: feedback.chat_id,
      user_id: feedback.user_id,
      feedback_type: feedback.feedback_type,
      generation_type: feedback.generation_type,
      user_prompt: feedback.user_prompt,
      feedback_content: feedback.feedback_content,
      created_at: feedback.created_at,
      updated_at: feedback.updated_at,
    };
  }
}
