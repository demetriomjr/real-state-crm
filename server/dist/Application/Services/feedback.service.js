"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var FeedbackService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedbackService = void 0;
const common_1 = require("@nestjs/common");
const feedback_repository_1 = require("../../Infrastructure/Repositories/feedback.repository");
const message_repository_1 = require("../../Infrastructure/Repositories/message.repository");
let FeedbackService = FeedbackService_1 = class FeedbackService {
    constructor(feedbackRepository, messageRepository) {
        this.feedbackRepository = feedbackRepository;
        this.messageRepository = messageRepository;
        this.logger = new common_1.Logger(FeedbackService_1.name);
    }
    async findAll(page = 1, limit = 10) {
        this.logger.log(`Fetching feedbacks with pagination: page=${page}, limit=${limit}`);
        const result = await this.feedbackRepository.findAll(page, limit);
        return {
            feedbacks: result.feedbacks.map((feedback) => this.mapToResponseDto(feedback)),
            total: result.total,
            page,
            limit,
        };
    }
    async findOne(id) {
        this.logger.log(`Fetching feedback with ID: ${id}`);
        const feedback = await this.feedbackRepository.findOne(id);
        if (!feedback) {
            this.logger.warn(`Feedback with ID ${id} not found`);
            throw new common_1.NotFoundException(`Feedback with ID ${id} not found`);
        }
        return this.mapToResponseDto(feedback);
    }
    async findByChatId(chatId) {
        this.logger.log(`Fetching feedbacks for chat: ${chatId}`);
        const feedbacks = await this.feedbackRepository.findByChatId(chatId);
        return feedbacks.map((feedback) => this.mapToResponseDto(feedback));
    }
    async create(createFeedbackDto) {
        this.logger.log(`Creating new feedback for chat: ${createFeedbackDto.chat_id}`);
        let messageIds = createFeedbackDto.message_ids;
        if (!messageIds || messageIds.length === 0) {
            const lastMessage = await this.messageRepository.findByChatId(createFeedbackDto.chat_id, undefined, 1, 1);
            if (lastMessage.messages.length > 0) {
                messageIds = [lastMessage.messages[0].message_id];
            }
        }
        const feedbackContent = await this.generateAIFeedback(createFeedbackDto.user_prompt, messageIds);
        const feedbackType = this.analyzeFeedbackType(feedbackContent);
        const feedback = await this.feedbackRepository.create({
            ...createFeedbackDto,
            feedback_type: feedbackType,
            generation_type: createFeedbackDto.user_prompt
                ? "user_prompt"
                : "ai_suggestion",
            feedback_content: feedbackContent,
        });
        this.logger.log(`Feedback created successfully with ID: ${feedback.id}`);
        return this.mapToResponseDto(feedback);
    }
    async generateAIFeedback(userPrompt, messageIds) {
        if (userPrompt) {
            return `AI Feedback based on user prompt: "${userPrompt}". This is a sample feedback response that would be generated by the AI system.`;
        }
        else {
            return `AI-generated feedback based on message analysis. This feedback suggests ways to improve customer engagement and conversion.`;
        }
    }
    analyzeFeedbackType(feedbackContent) {
        const positiveKeywords = [
            "good",
            "great",
            "excellent",
            "positive",
            "improve",
            "success",
        ];
        const negativeKeywords = [
            "bad",
            "poor",
            "negative",
            "problem",
            "issue",
            "fail",
        ];
        const content = feedbackContent.toLowerCase();
        const positiveCount = positiveKeywords.filter((keyword) => content.includes(keyword)).length;
        const negativeCount = negativeKeywords.filter((keyword) => content.includes(keyword)).length;
        if (positiveCount > negativeCount) {
            return "positive";
        }
        else if (negativeCount > positiveCount) {
            return "negative";
        }
        else {
            return "neutral";
        }
    }
    async purge(id) {
        this.logger.warn(`PURGING feedback with ID: ${id} - PERMANENT DELETION`);
        const existingFeedback = await this.feedbackRepository.findOne(id);
        if (!existingFeedback) {
            this.logger.warn(`Feedback with ID ${id} not found for purge`);
            throw new common_1.NotFoundException(`Feedback with ID ${id} not found`);
        }
        await this.feedbackRepository.purge(id);
        this.logger.warn(`Feedback PURGED permanently with ID: ${id}`);
    }
    async purgeByChat(chatId) {
        this.logger.warn(`PURGING all feedbacks for chat: ${chatId} - PERMANENT DELETION`);
        await this.feedbackRepository.purgeByChat(chatId);
        this.logger.warn(`All feedbacks PURGED permanently for chat: ${chatId}`);
    }
    mapToResponseDto(feedback) {
        return {
            id: feedback.id,
            chat_id: feedback.chat_id,
            user_id: feedback.user_id,
            feedback_type: feedback.feedback_type,
            generation_type: feedback.generation_type,
            user_prompt: feedback.user_prompt,
            feedback_content: feedback.feedback_content,
            created_at: feedback.created_at,
            updated_at: feedback.updated_at,
        };
    }
};
exports.FeedbackService = FeedbackService;
exports.FeedbackService = FeedbackService = FeedbackService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [feedback_repository_1.FeedbackRepository,
        message_repository_1.MessageRepository])
], FeedbackService);
//# sourceMappingURL=feedback.service.js.map